// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: edge-based-graph.proto

#ifndef PROTOBUF_INCLUDED_edge_2dbased_2dgraph_2eproto
#define PROTOBUF_INCLUDED_edge_2dbased_2dgraph_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_edge_2dbased_2dgraph_2eproto 

namespace protobuf_edge_2dbased_2dgraph_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_edge_2dbased_2dgraph_2eproto
namespace pbebg {
class EdgeBasedNode;
class EdgeBasedNodeDefaultTypeInternal;
extern EdgeBasedNodeDefaultTypeInternal _EdgeBasedNode_default_instance_;
class EdgeBasedNodeContainer;
class EdgeBasedNodeContainerDefaultTypeInternal;
extern EdgeBasedNodeContainerDefaultTypeInternal _EdgeBasedNodeContainer_default_instance_;
class NodeBasedAnnotation;
class NodeBasedAnnotationDefaultTypeInternal;
extern NodeBasedAnnotationDefaultTypeInternal _NodeBasedAnnotation_default_instance_;
class TurnInstructions;
class TurnInstructionsDefaultTypeInternal;
extern TurnInstructionsDefaultTypeInternal _TurnInstructions_default_instance_;
class TurnPenalties;
class TurnPenaltiesDefaultTypeInternal;
extern TurnPenaltiesDefaultTypeInternal _TurnPenalties_default_instance_;
}  // namespace pbebg
namespace google {
namespace protobuf {
template<> ::pbebg::EdgeBasedNode* Arena::CreateMaybeMessage<::pbebg::EdgeBasedNode>(Arena*);
template<> ::pbebg::EdgeBasedNodeContainer* Arena::CreateMaybeMessage<::pbebg::EdgeBasedNodeContainer>(Arena*);
template<> ::pbebg::NodeBasedAnnotation* Arena::CreateMaybeMessage<::pbebg::NodeBasedAnnotation>(Arena*);
template<> ::pbebg::TurnInstructions* Arena::CreateMaybeMessage<::pbebg::TurnInstructions>(Arena*);
template<> ::pbebg::TurnPenalties* Arena::CreateMaybeMessage<::pbebg::TurnPenalties>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pbebg {

// ===================================================================

class EdgeBasedNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pbebg.EdgeBasedNode) */ {
 public:
  EdgeBasedNode();
  virtual ~EdgeBasedNode();

  EdgeBasedNode(const EdgeBasedNode& from);

  inline EdgeBasedNode& operator=(const EdgeBasedNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeBasedNode(EdgeBasedNode&& from) noexcept
    : EdgeBasedNode() {
    *this = ::std::move(from);
  }

  inline EdgeBasedNode& operator=(EdgeBasedNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeBasedNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeBasedNode* internal_default_instance() {
    return reinterpret_cast<const EdgeBasedNode*>(
               &_EdgeBasedNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EdgeBasedNode* other);
  friend void swap(EdgeBasedNode& a, EdgeBasedNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeBasedNode* New() const final {
    return CreateMaybeMessage<EdgeBasedNode>(NULL);
  }

  EdgeBasedNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeBasedNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeBasedNode& from);
  void MergeFrom(const EdgeBasedNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeBasedNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 geometry_id = 1;
  void clear_geometry_id();
  static const int kGeometryIdFieldNumber = 1;
  ::google::protobuf::uint32 geometry_id() const;
  void set_geometry_id(::google::protobuf::uint32 value);

  // uint32 component_id = 2;
  void clear_component_id();
  static const int kComponentIdFieldNumber = 2;
  ::google::protobuf::uint32 component_id() const;
  void set_component_id(::google::protobuf::uint32 value);

  // uint32 annotation_id = 3;
  void clear_annotation_id();
  static const int kAnnotationIdFieldNumber = 3;
  ::google::protobuf::uint32 annotation_id() const;
  void set_annotation_id(::google::protobuf::uint32 value);

  // bool is_tiny = 4;
  void clear_is_tiny();
  static const int kIsTinyFieldNumber = 4;
  bool is_tiny() const;
  void set_is_tiny(bool value);

  // bool segregated = 5;
  void clear_segregated();
  static const int kSegregatedFieldNumber = 5;
  bool segregated() const;
  void set_segregated(bool value);

  // @@protoc_insertion_point(class_scope:pbebg.EdgeBasedNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 geometry_id_;
  ::google::protobuf::uint32 component_id_;
  ::google::protobuf::uint32 annotation_id_;
  bool is_tiny_;
  bool segregated_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_edge_2dbased_2dgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeBasedAnnotation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pbebg.NodeBasedAnnotation) */ {
 public:
  NodeBasedAnnotation();
  virtual ~NodeBasedAnnotation();

  NodeBasedAnnotation(const NodeBasedAnnotation& from);

  inline NodeBasedAnnotation& operator=(const NodeBasedAnnotation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeBasedAnnotation(NodeBasedAnnotation&& from) noexcept
    : NodeBasedAnnotation() {
    *this = ::std::move(from);
  }

  inline NodeBasedAnnotation& operator=(NodeBasedAnnotation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeBasedAnnotation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeBasedAnnotation* internal_default_instance() {
    return reinterpret_cast<const NodeBasedAnnotation*>(
               &_NodeBasedAnnotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NodeBasedAnnotation* other);
  friend void swap(NodeBasedAnnotation& a, NodeBasedAnnotation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeBasedAnnotation* New() const final {
    return CreateMaybeMessage<NodeBasedAnnotation>(NULL);
  }

  NodeBasedAnnotation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeBasedAnnotation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeBasedAnnotation& from);
  void MergeFrom(const NodeBasedAnnotation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeBasedAnnotation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 name_id = 1;
  void clear_name_id();
  static const int kNameIdFieldNumber = 1;
  ::google::protobuf::uint32 name_id() const;
  void set_name_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pbebg.NodeBasedAnnotation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 name_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_edge_2dbased_2dgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgeBasedNodeContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pbebg.EdgeBasedNodeContainer) */ {
 public:
  EdgeBasedNodeContainer();
  virtual ~EdgeBasedNodeContainer();

  EdgeBasedNodeContainer(const EdgeBasedNodeContainer& from);

  inline EdgeBasedNodeContainer& operator=(const EdgeBasedNodeContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgeBasedNodeContainer(EdgeBasedNodeContainer&& from) noexcept
    : EdgeBasedNodeContainer() {
    *this = ::std::move(from);
  }

  inline EdgeBasedNodeContainer& operator=(EdgeBasedNodeContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgeBasedNodeContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EdgeBasedNodeContainer* internal_default_instance() {
    return reinterpret_cast<const EdgeBasedNodeContainer*>(
               &_EdgeBasedNodeContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EdgeBasedNodeContainer* other);
  friend void swap(EdgeBasedNodeContainer& a, EdgeBasedNodeContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgeBasedNodeContainer* New() const final {
    return CreateMaybeMessage<EdgeBasedNodeContainer>(NULL);
  }

  EdgeBasedNodeContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EdgeBasedNodeContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EdgeBasedNodeContainer& from);
  void MergeFrom(const EdgeBasedNodeContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgeBasedNodeContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pbebg.EdgeBasedNode nodes = 1;
  int nodes_size() const;
  void clear_nodes();
  static const int kNodesFieldNumber = 1;
  ::pbebg::EdgeBasedNode* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField< ::pbebg::EdgeBasedNode >*
      mutable_nodes();
  const ::pbebg::EdgeBasedNode& nodes(int index) const;
  ::pbebg::EdgeBasedNode* add_nodes();
  const ::google::protobuf::RepeatedPtrField< ::pbebg::EdgeBasedNode >&
      nodes() const;

  // repeated .pbebg.NodeBasedAnnotation annotation_data = 2;
  int annotation_data_size() const;
  void clear_annotation_data();
  static const int kAnnotationDataFieldNumber = 2;
  ::pbebg::NodeBasedAnnotation* mutable_annotation_data(int index);
  ::google::protobuf::RepeatedPtrField< ::pbebg::NodeBasedAnnotation >*
      mutable_annotation_data();
  const ::pbebg::NodeBasedAnnotation& annotation_data(int index) const;
  ::pbebg::NodeBasedAnnotation* add_annotation_data();
  const ::google::protobuf::RepeatedPtrField< ::pbebg::NodeBasedAnnotation >&
      annotation_data() const;

  // @@protoc_insertion_point(class_scope:pbebg.EdgeBasedNodeContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pbebg::EdgeBasedNode > nodes_;
  ::google::protobuf::RepeatedPtrField< ::pbebg::NodeBasedAnnotation > annotation_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_edge_2dbased_2dgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TurnInstructions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pbebg.TurnInstructions) */ {
 public:
  TurnInstructions();
  virtual ~TurnInstructions();

  TurnInstructions(const TurnInstructions& from);

  inline TurnInstructions& operator=(const TurnInstructions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TurnInstructions(TurnInstructions&& from) noexcept
    : TurnInstructions() {
    *this = ::std::move(from);
  }

  inline TurnInstructions& operator=(TurnInstructions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TurnInstructions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnInstructions* internal_default_instance() {
    return reinterpret_cast<const TurnInstructions*>(
               &_TurnInstructions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TurnInstructions* other);
  friend void swap(TurnInstructions& a, TurnInstructions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TurnInstructions* New() const final {
    return CreateMaybeMessage<TurnInstructions>(NULL);
  }

  TurnInstructions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TurnInstructions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TurnInstructions& from);
  void MergeFrom(const TurnInstructions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnInstructions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 turn_instruction = 1;
  int turn_instruction_size() const;
  void clear_turn_instruction();
  static const int kTurnInstructionFieldNumber = 1;
  ::google::protobuf::uint32 turn_instruction(int index) const;
  void set_turn_instruction(int index, ::google::protobuf::uint32 value);
  void add_turn_instruction(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      turn_instruction() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_turn_instruction();

  // @@protoc_insertion_point(class_scope:pbebg.TurnInstructions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > turn_instruction_;
  mutable int _turn_instruction_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_edge_2dbased_2dgraph_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TurnPenalties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pbebg.TurnPenalties) */ {
 public:
  TurnPenalties();
  virtual ~TurnPenalties();

  TurnPenalties(const TurnPenalties& from);

  inline TurnPenalties& operator=(const TurnPenalties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TurnPenalties(TurnPenalties&& from) noexcept
    : TurnPenalties() {
    *this = ::std::move(from);
  }

  inline TurnPenalties& operator=(TurnPenalties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TurnPenalties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnPenalties* internal_default_instance() {
    return reinterpret_cast<const TurnPenalties*>(
               &_TurnPenalties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TurnPenalties* other);
  friend void swap(TurnPenalties& a, TurnPenalties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TurnPenalties* New() const final {
    return CreateMaybeMessage<TurnPenalties>(NULL);
  }

  TurnPenalties* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TurnPenalties>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TurnPenalties& from);
  void MergeFrom(const TurnPenalties& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnPenalties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 turn_penalties = 1;
  int turn_penalties_size() const;
  void clear_turn_penalties();
  static const int kTurnPenaltiesFieldNumber = 1;
  ::google::protobuf::uint32 turn_penalties(int index) const;
  void set_turn_penalties(int index, ::google::protobuf::uint32 value);
  void add_turn_penalties(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      turn_penalties() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_turn_penalties();

  // @@protoc_insertion_point(class_scope:pbebg.TurnPenalties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > turn_penalties_;
  mutable int _turn_penalties_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_edge_2dbased_2dgraph_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EdgeBasedNode

// uint32 geometry_id = 1;
inline void EdgeBasedNode::clear_geometry_id() {
  geometry_id_ = 0u;
}
inline ::google::protobuf::uint32 EdgeBasedNode::geometry_id() const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNode.geometry_id)
  return geometry_id_;
}
inline void EdgeBasedNode::set_geometry_id(::google::protobuf::uint32 value) {
  
  geometry_id_ = value;
  // @@protoc_insertion_point(field_set:pbebg.EdgeBasedNode.geometry_id)
}

// uint32 component_id = 2;
inline void EdgeBasedNode::clear_component_id() {
  component_id_ = 0u;
}
inline ::google::protobuf::uint32 EdgeBasedNode::component_id() const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNode.component_id)
  return component_id_;
}
inline void EdgeBasedNode::set_component_id(::google::protobuf::uint32 value) {
  
  component_id_ = value;
  // @@protoc_insertion_point(field_set:pbebg.EdgeBasedNode.component_id)
}

// uint32 annotation_id = 3;
inline void EdgeBasedNode::clear_annotation_id() {
  annotation_id_ = 0u;
}
inline ::google::protobuf::uint32 EdgeBasedNode::annotation_id() const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNode.annotation_id)
  return annotation_id_;
}
inline void EdgeBasedNode::set_annotation_id(::google::protobuf::uint32 value) {
  
  annotation_id_ = value;
  // @@protoc_insertion_point(field_set:pbebg.EdgeBasedNode.annotation_id)
}

// bool is_tiny = 4;
inline void EdgeBasedNode::clear_is_tiny() {
  is_tiny_ = false;
}
inline bool EdgeBasedNode::is_tiny() const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNode.is_tiny)
  return is_tiny_;
}
inline void EdgeBasedNode::set_is_tiny(bool value) {
  
  is_tiny_ = value;
  // @@protoc_insertion_point(field_set:pbebg.EdgeBasedNode.is_tiny)
}

// bool segregated = 5;
inline void EdgeBasedNode::clear_segregated() {
  segregated_ = false;
}
inline bool EdgeBasedNode::segregated() const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNode.segregated)
  return segregated_;
}
inline void EdgeBasedNode::set_segregated(bool value) {
  
  segregated_ = value;
  // @@protoc_insertion_point(field_set:pbebg.EdgeBasedNode.segregated)
}

// -------------------------------------------------------------------

// NodeBasedAnnotation

// uint32 name_id = 1;
inline void NodeBasedAnnotation::clear_name_id() {
  name_id_ = 0u;
}
inline ::google::protobuf::uint32 NodeBasedAnnotation::name_id() const {
  // @@protoc_insertion_point(field_get:pbebg.NodeBasedAnnotation.name_id)
  return name_id_;
}
inline void NodeBasedAnnotation::set_name_id(::google::protobuf::uint32 value) {
  
  name_id_ = value;
  // @@protoc_insertion_point(field_set:pbebg.NodeBasedAnnotation.name_id)
}

// -------------------------------------------------------------------

// EdgeBasedNodeContainer

// repeated .pbebg.EdgeBasedNode nodes = 1;
inline int EdgeBasedNodeContainer::nodes_size() const {
  return nodes_.size();
}
inline void EdgeBasedNodeContainer::clear_nodes() {
  nodes_.Clear();
}
inline ::pbebg::EdgeBasedNode* EdgeBasedNodeContainer::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:pbebg.EdgeBasedNodeContainer.nodes)
  return nodes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pbebg::EdgeBasedNode >*
EdgeBasedNodeContainer::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:pbebg.EdgeBasedNodeContainer.nodes)
  return &nodes_;
}
inline const ::pbebg::EdgeBasedNode& EdgeBasedNodeContainer::nodes(int index) const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNodeContainer.nodes)
  return nodes_.Get(index);
}
inline ::pbebg::EdgeBasedNode* EdgeBasedNodeContainer::add_nodes() {
  // @@protoc_insertion_point(field_add:pbebg.EdgeBasedNodeContainer.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbebg::EdgeBasedNode >&
EdgeBasedNodeContainer::nodes() const {
  // @@protoc_insertion_point(field_list:pbebg.EdgeBasedNodeContainer.nodes)
  return nodes_;
}

// repeated .pbebg.NodeBasedAnnotation annotation_data = 2;
inline int EdgeBasedNodeContainer::annotation_data_size() const {
  return annotation_data_.size();
}
inline void EdgeBasedNodeContainer::clear_annotation_data() {
  annotation_data_.Clear();
}
inline ::pbebg::NodeBasedAnnotation* EdgeBasedNodeContainer::mutable_annotation_data(int index) {
  // @@protoc_insertion_point(field_mutable:pbebg.EdgeBasedNodeContainer.annotation_data)
  return annotation_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pbebg::NodeBasedAnnotation >*
EdgeBasedNodeContainer::mutable_annotation_data() {
  // @@protoc_insertion_point(field_mutable_list:pbebg.EdgeBasedNodeContainer.annotation_data)
  return &annotation_data_;
}
inline const ::pbebg::NodeBasedAnnotation& EdgeBasedNodeContainer::annotation_data(int index) const {
  // @@protoc_insertion_point(field_get:pbebg.EdgeBasedNodeContainer.annotation_data)
  return annotation_data_.Get(index);
}
inline ::pbebg::NodeBasedAnnotation* EdgeBasedNodeContainer::add_annotation_data() {
  // @@protoc_insertion_point(field_add:pbebg.EdgeBasedNodeContainer.annotation_data)
  return annotation_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbebg::NodeBasedAnnotation >&
EdgeBasedNodeContainer::annotation_data() const {
  // @@protoc_insertion_point(field_list:pbebg.EdgeBasedNodeContainer.annotation_data)
  return annotation_data_;
}

// -------------------------------------------------------------------

// TurnInstructions

// repeated uint32 turn_instruction = 1;
inline int TurnInstructions::turn_instruction_size() const {
  return turn_instruction_.size();
}
inline void TurnInstructions::clear_turn_instruction() {
  turn_instruction_.Clear();
}
inline ::google::protobuf::uint32 TurnInstructions::turn_instruction(int index) const {
  // @@protoc_insertion_point(field_get:pbebg.TurnInstructions.turn_instruction)
  return turn_instruction_.Get(index);
}
inline void TurnInstructions::set_turn_instruction(int index, ::google::protobuf::uint32 value) {
  turn_instruction_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbebg.TurnInstructions.turn_instruction)
}
inline void TurnInstructions::add_turn_instruction(::google::protobuf::uint32 value) {
  turn_instruction_.Add(value);
  // @@protoc_insertion_point(field_add:pbebg.TurnInstructions.turn_instruction)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TurnInstructions::turn_instruction() const {
  // @@protoc_insertion_point(field_list:pbebg.TurnInstructions.turn_instruction)
  return turn_instruction_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TurnInstructions::mutable_turn_instruction() {
  // @@protoc_insertion_point(field_mutable_list:pbebg.TurnInstructions.turn_instruction)
  return &turn_instruction_;
}

// -------------------------------------------------------------------

// TurnPenalties

// repeated uint32 turn_penalties = 1;
inline int TurnPenalties::turn_penalties_size() const {
  return turn_penalties_.size();
}
inline void TurnPenalties::clear_turn_penalties() {
  turn_penalties_.Clear();
}
inline ::google::protobuf::uint32 TurnPenalties::turn_penalties(int index) const {
  // @@protoc_insertion_point(field_get:pbebg.TurnPenalties.turn_penalties)
  return turn_penalties_.Get(index);
}
inline void TurnPenalties::set_turn_penalties(int index, ::google::protobuf::uint32 value) {
  turn_penalties_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbebg.TurnPenalties.turn_penalties)
}
inline void TurnPenalties::add_turn_penalties(::google::protobuf::uint32 value) {
  turn_penalties_.Add(value);
  // @@protoc_insertion_point(field_add:pbebg.TurnPenalties.turn_penalties)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TurnPenalties::turn_penalties() const {
  // @@protoc_insertion_point(field_list:pbebg.TurnPenalties.turn_penalties)
  return turn_penalties_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TurnPenalties::mutable_turn_penalties() {
  // @@protoc_insertion_point(field_mutable_list:pbebg.TurnPenalties.turn_penalties)
  return &turn_penalties_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbebg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_edge_2dbased_2dgraph_2eproto
